/*
 * Milyn - Copyright (C) 2006
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License (version 2.1) as published
 * by the Free Software Foundation.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU Lesser General Public License for more details:
 * http://www.gnu.org/licenses/lgpl.txt
 */

package org.milyn.routing.file;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.milyn.SmooksException;
import org.milyn.cdr.SmooksConfigurationException;
import org.milyn.cdr.annotation.ConfigParam;
import org.milyn.container.ExecutionContext;
import org.milyn.delivery.annotation.Initialize;
import org.milyn.io.AbstractOutputStreamResource;
import org.milyn.javabean.BeanAccessor;
import org.milyn.util.DollarBraceDecoder;
import org.milyn.util.FreeMarkerTemplate;

import java.io.*;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * FileOutputStreamResouce is a {@link AbstractOutputStreamResource} implementation
 * that handles file output streams. 
 * <p/>
 * 
 * Example configuration:
 * <pre>
 * &lt;resource-config selector="order-item"&gt;
 *    &lt;resource&gt;org.milyn.io.file.FileOutputStreamResource&lt;/resource&gt;
 *    &lt;param name="resourceName"&gt;resourceName&lt;/param&gt;
 *    &lt;param name="fileNamePattern"&gt;orderitem-${order.orderId}-${order.orderItem.itemId}.xml&lt;/param&gt;
 *    &lt;param name="listFileNamePattern"&gt;orderitems-${order.orderId}.lst&lt;/param&gt;
 *    &lt;param name="destinationDirectory"&gt;/dirname&lt;/param&gt;
 * &lt;/resource-config&gt;
 * 
 * Optional properties:
 *    &lt;param name="highWaterMark"&gt;200&lt;/param&gt;
 *    &lt;param name="highWaterMarkTimeout"&gt;60000&lt;/param&gt;
 *    
 * </pre>
 * 
 * Description of configuration properties:
 * <ul>
 * <li><code>resourceName</code>: the name of this resouce. Will be used to identify this resource.
 * <li><code>fileNamePattern</code>: is the pattern that will be used to generate file names. The file is
 *      created in the destinationDirectory.  Supports templating.
 * <li><code>listFileNamePattern</code>: is name of the file that will contain the file names generated by this
 *      configuration. The file is created in the destinationDirectory.  Supports templating.
 * <li><code>destinationDirectory</code>: is the destination directory for files created by this router
 * <li><code>highWaterMark</code>: 
 * <li><code>highWaterMarkTimeout</code>: 
 * </ul>
 * 
 * @author <a href="mailto:daniel.bevenius@gmail.com">Daniel Bevenius</a>
 */
public class FileOutputStreamResource extends AbstractOutputStreamResource
{
    private static final String TMP_FILE_CONTEXT_KEY_PREFIX = FileOutputStreamResource.class.getName() + "#tmpFile:";
    
	private static final String LINE_SEPARATOR = System.getProperty( "line.separator" );
	
	private static Log logger = LogFactory.getLog( FileOutputStreamResource.class );
    
    @ConfigParam(name = "fileNamePattern")
    private String fileNamePattern;
    private FreeMarkerTemplate fileNameTemplate;

    @ConfigParam ( name = "destinationDirectory" )
	private String destinationDirectoryName;
    private File destinationDirectory;
    private FileFilter fileFilter;

    @ConfigParam(use = ConfigParam.Use.OPTIONAL)
    private String listFileNamePattern;
    private FreeMarkerTemplate listFileNameTemplate;

    private String listFileNamePatternCtxKey;

    @ConfigParam(defaultVal = "200")
    private int highWaterMark;
    @ConfigParam(defaultVal = "60000")
    private long highWaterMarkTimeout;

    //	public
    
    @Initialize
    public void intialize() {
        fileNameTemplate = new FreeMarkerTemplate( fileNamePattern );
        listFileNameTemplate = new FreeMarkerTemplate(listFileNamePattern);

        destinationDirectory = new File(destinationDirectoryName);
        if(!destinationDirectory.exists() || !destinationDirectory.isDirectory()) {
            throw new SmooksConfigurationException("destinationDirectory '" + destinationDirectory.getAbsolutePath() + "' doesn't exist or is not a directory.");
        }

        fileFilter = new SplitFilenameFilter(fileNamePattern);
        
        if(listFileNamePattern != null) {
            listFileNamePatternCtxKey = FileOutputStreamResource.class.getName() + "#" + listFileNamePattern;
        }
    }

    @Override
	public FileOutputStream getOutputStream( final ExecutionContext executionContext ) throws IOException
	{
        waitWhileAboveHighWaterMark();

        final File tmpFile = File.createTempFile( UUID.randomUUID().toString(), ".working", destinationDirectory );
		final FileOutputStream fileOutputStream = new FileOutputStream( tmpFile , true );
		executionContext.setAttribute( TMP_FILE_CONTEXT_KEY_PREFIX + getResourceName(), tmpFile );
		return fileOutputStream;
	}

    private void waitWhileAboveHighWaterMark() throws IOException {
        if(highWaterMark == -1) {
            return;
        }

        File[] currentList = destinationDirectory.listFiles(fileFilter);
        if(currentList.length >= highWaterMark) {
            long start = System.currentTimeMillis();

            while(System.currentTimeMillis() < start + highWaterMarkTimeout) {
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    logger.error("Interrupted", e);
                    return;
                }
                currentList = destinationDirectory.listFiles(fileFilter);
                if(currentList.length < highWaterMark) {
                    return;
                }
            }

            throw new IOException("Unable to open file output stream.  Timed out waiting for the number of '" + listFileNamePattern + "' files in '" + destinationDirectory.getAbsolutePath() +  "' to drop below " + highWaterMark + ".  Consider increasing 'highWaterMark' param value.");
        }
    }

    @Override
	protected void closeResource( ExecutionContext executionContext )
	{
        try {
            super.closeResource(executionContext);
        } finally {
            File newFile = renameWorkingFile(executionContext);
            if(newFile != null) {
                addToListFile( executionContext, newFile );
            }
        }
	}
    
    //	private

    private File renameWorkingFile(ExecutionContext executionContext) {
        File workingFile = (File) executionContext.getAttribute( TMP_FILE_CONTEXT_KEY_PREFIX + getResourceName() );

        if ( workingFile == null || !workingFile.exists() )
        {
            return null;
        }

        String newFileName;
        Map beanMap = BeanAccessor.getBeanMap( executionContext );

        //	BeanAccessor guarantees to return a beanMap... run the filename pattern
        // through FreeMarker to generate the file name...
        newFileName = fileNameTemplate.apply( beanMap );

        //	create a new file in the destination directory
        File newFile = new File( destinationDirectory, newFileName );

        if(newFile.exists()) {
            throw new SmooksException( "Could not rename [" + workingFile.getAbsolutePath() + "] to [" + newFile.getAbsolutePath() + "]. [" + newFile.getAbsolutePath() + "] already exists.");
        }

        //	try to rename the tmp file to the new file
        boolean renameTo = workingFile.renameTo( newFile ) ;
        if ( !renameTo )
        {
            throw new SmooksException( "Could not rename [" + workingFile.getAbsolutePath() + "] to [" + newFile.getAbsolutePath() + "]");
        }
        workingFile.delete();

        return newFile;
    }

    private void addToListFile( ExecutionContext executionContext, File newFile )
	{
        if(listFileNamePatternCtxKey != null) {
            FileWriter writer = (FileWriter) executionContext.getAttribute(listFileNamePatternCtxKey);

            if(writer == null) {
                String listFileName = getListFileName(executionContext);
                File listFile = new File ( destinationDirectory, listFileName );

                FileListAccessor.addFileName( listFile.getAbsolutePath(), executionContext );
                try {
                    writer = new FileWriter( listFile );
                    executionContext.setAttribute(listFileNamePatternCtxKey, writer);
                } catch (IOException e) {
                    throw new SmooksException("", e);
                }
            }

            try
            {
                writer.write( newFile.getAbsolutePath() + LINE_SEPARATOR );
                writer.flush();
            }
            catch (IOException e)
            {
                throw new SmooksException ( "IOException while trying to write to list file [" + getListFileName(executionContext) + "] :", e );
            }
        }
    }

    public void executeExecutionLifecycleCleanup(ExecutionContext executionContext) {
        super.executeExecutionLifecycleCleanup(executionContext);

        // Close the list file, if there's one open...
        if(listFileNamePatternCtxKey != null) {
            FileWriter writer = (FileWriter) executionContext.getAttribute(listFileNamePatternCtxKey);

            if(writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    logger.error("Failed to close list file '" + getListFileName(executionContext) + "'.", e);
                }
            }
        }
    }

    private String getListFileName(ExecutionContext executionContext) {
        return listFileNameTemplate.apply(BeanAccessor.getBeanMap(executionContext));
    }

    private class SplitFilenameFilter implements FileFilter {

        private Pattern regexpPattern;

        private SplitFilenameFilter(String filenamePattern) {
            // Convert the filename pattern to a regexp...
            String pattern = DollarBraceDecoder.replaceTokens(filenamePattern, ".*");
            regexpPattern = Pattern.compile(pattern);
        }

        public boolean accept(File file) {
            Matcher matcher = regexpPattern.matcher(file.getName());
            return matcher.matches();
        }
    }
}
