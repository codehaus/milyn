/*
 * Milyn - Copyright (C) 2006
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License (version 2.1) as published
 * by the Free Software Foundation.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU Lesser General Public License for more details:
 * http://www.gnu.org/licenses/lgpl.txt
 */

package org.milyn.routing.file;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.UUID;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.milyn.SmooksException;
import org.milyn.cdr.annotation.ConfigParam;
import org.milyn.cdr.annotation.ConfigParam.Use;
import org.milyn.container.ExecutionContext;
import org.milyn.io.AbstractOutputStreamResource;
import org.milyn.javabean.BeanAccessor;
import org.milyn.util.FreeMarkerTemplate;

/**
 * FileOutputStreamResouce is a {@link AbstractOutputStreamResource} implementation
 * that handles file output streams. 
 * <p/>
 * 
 * Example configuration:
 * <pre>
 * &lt;resource-config selector="$document"&gt;
 *    &lt;resource&gt;org.milyn.io.file.FileOutputStreamResource&lt;/resource&gt;
 *    &lt;param name="resourceName"&gt;resourceName&lt;/param&gt;
 *    &lt;param name="fileNamePattern"&gt;${orderId}&lt;/param&gt;
 *    &lt;param name="destinationDirectory"&gt;/dirname&lt;/param&gt;
 *    &lt;param name="listFileName"&gt;Orders-${country}.lst&lt;/param&gt;
 * &lt;/resource-config&gt;
 * </pre>
 * 
 * Description of configuration properties:
 * <ul>
 * <li><code>resourceName </code> the name of this resouce. Will be used to identify this resource.
 * <li><code>fileNamePattern </code> is the pattern that will be used to name the generated files. Supports templating
 * <li><code>destinationDirectory </code> is the destination directory for files created by this router
 * <li><code>listFileName</code> is name of the file that will contain the file names generated by this configuration. Supports templating 
 * </ul>
 * 
 * @author <a href="mailto:daniel.bevenius@gmail.com">Daniel Bevenius</a>
 */
public class FileOutputStreamResource extends AbstractOutputStreamResource
{
    private static final String TMP_FILE_CONTEXT_KEY_PREFIX = FileOutputStreamResource.class.getName() + "#tmpFile:";
    
	private static final String LINE_SEPARATOR = System.getProperty( "line.separator" );
	
	private Log log = LogFactory.getLog( FileOutputStreamResource.class );
    
    @ConfigParam(name = "resourceName")
    private String resourceName;
    
    @ConfigParam(name = "fileNamePattern")
    private String fileNamePattern;
    
	@ConfigParam ( name = "destinationDirectory", use = Use.REQUIRED )
	private String destinationDirectoryName;
	
    @ConfigParam(name = "listFileName")
    private String listFileName;
    
	private FreeMarkerTemplate template;
	
	//	public

	@Override
	public FileOutputStream getOutputStream( final ExecutionContext executionContext ) throws IOException
	{
		final File tmpFile = File.createTempFile( UUID.randomUUID().toString(), ".working" );
		final FileOutputStream fileOutputStream = new FileOutputStream( tmpFile , true );
		executionContext.setAttribute( TMP_FILE_CONTEXT_KEY_PREFIX + getResourceName(), tmpFile );
		return fileOutputStream;
	}

	@Override
	public String getResourceName()
	{
		return resourceName;
	}

	@Override
	protected void preUnbindFromExecutionContext( ExecutionContext executionContext )
	{
		File workingFile = (File) executionContext.getAttribute( TMP_FILE_CONTEXT_KEY_PREFIX + getResourceName() );
		if ( workingFile == null )
		{
			throw new SmooksException( "Could not find the tmp file in the execution context" );
		}
		
		//	this can happen if called from executeExecutionLifecycleCleanup
		if ( !workingFile.exists() )
		{
			return;
		}
		
		String newFileName;
        Object bean = BeanAccessor.getBeanMap( executionContext );
		if ( bean != null )
		{
    		//	run the filename pattern through FreeMarker
    		if ( template == null )
    		{
        		template = new FreeMarkerTemplate( fileNamePattern );
    		}
    		newFileName = template.apply( bean );
		}
		else
		{
			//	just use the fileNamePattern as the file name (not using template pattern)
    		newFileName = fileNamePattern;
		}
		
		//	create a new file in the destination directory
		File newFile = new File( destinationDirectoryName + File.separator + newFileName );
		
		//	try to rename the tmp file to the new file 
		boolean renameTo = workingFile.renameTo( newFile ) ;
		if ( !renameTo )
		{
			throw new SmooksException( "Could not rename [" + workingFile.getAbsolutePath() + "] to [" + newFile.getAbsolutePath() + "]");
		}
		workingFile.delete();
		
		addToListFile( executionContext, newFile );
		
	}
	
    //	private
    
	private void addToListFile( ExecutionContext executionContext, File newFile )
	{
		File listFile = new File ( destinationDirectoryName + File.separator + listFileName );
		FileListAccessor.addFileName( listFile.getAbsolutePath(), executionContext );
		
		FileWriter writer = null;
		try
		{
			writer = new FileWriter( listFile, true );
    		writer.write( newFile.getAbsolutePath() + LINE_SEPARATOR );
    		writer.flush();
		} 
		catch (IOException e)
		{
			throw new SmooksException ( "IOException while trying to write to list file [" + listFile.getAbsolutePath() + "] :", e );
		}
		finally
		{
			if ( writer != null )
			{
				try
				{
					writer.close();
				} 
				catch (IOException e)
				{
					log.error( "IOException while trying to close writer to file [" + listFile.getAbsolutePath() + "] : ", e );
				}
			}
		}
	}

}
