/*
	Milyn - Copyright (C) 2006

	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License (version 2.1) as published by the Free Software 
	Foundation.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
    
	See the GNU Lesser General Public License for more details:    
	http://www.gnu.org/licenses/lgpl.txt
*/

package org.milyn.templating.xslt;

import java.io.*;

import javax.xml.transform.*;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.stream.StreamResult;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.milyn.cdr.SmooksResourceConfiguration;
import org.milyn.container.ExecutionContext;
import org.milyn.delivery.ContentDeliveryUnit;
import org.milyn.delivery.ContentDeliveryUnitCreator;
import org.milyn.io.StreamUtils;
import org.milyn.templating.AbstractTemplateProcessingUnit;
import org.milyn.util.ClassUtil;
import org.milyn.xml.DomUtils;
import org.milyn.xml.Namespace;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;


/**
 * XSL {@link org.milyn.delivery.dom.DOMElementVisitor} Creator class.
 * <p/>
 * Creates {@link org.milyn.delivery.ContentDeliveryUnit} instances for performing node/element level
 * <a href="http://www.w3.org/Style/XSL/">XSL</a> templating (aka XSLT).
 * <p/>
 * Template application can be done in a synchonized or unsynchonized fashion by setting
 * the system property "org.milyn.templating.xslt.synchronized".  According to the spec,
 * this should not be necessary.  However, Xalan 2.7.0 (for one) has a bug which results in
 * unsynchronized template application causing invalid transforms.
 * 
 * <h3>.cdrl Configuration</h3>
 * Two configurations are required in order to use <a href="http://www.w3.org/Style/XSL/">XSL</a>
 * based templating:
 * <ol>
 *  <li>A Configuration to register this {@link org.milyn.delivery.ContentDeliveryUnitCreator}
 *      implementation.  This configuration basically tells Smooks how to handle ".xsl" files (or restype param "xsl").
 *  </li>
 *  <li>Configurations for targeting the "xsl" templates.
 *  </li>
 * </ol>
 * 
 * <h4>1. Registering XslContentDeliveryUnitCreator to Handle "xsl" resource types</h4>
 * <pre>
 * &lt;smooks-resource selector="cdu-creator" path="<b>org.milyn.templating.xslt.XslContentDeliveryUnitCreator</b>" &gt;
 * 
 *  &lt;!-- 
 *      (Mandatory) Specifying the resource type.  This param basically tells Smooks to use the {@link XslContentDeliveryUnitCreator} to
 *      create {@link org.milyn.delivery.dom.DOMElementVisitor} instances for handling "xsl" resources.
 *  --&gt;
 *  &lt;param name="<b>restype</b>"&gt;xsl&lt;/param&gt;
 * 
 * &lt;/smooks-resource&gt;
 * </pre>
 * <p/>
 * Registration of the {@link XslContentDeliveryUnitCreator} to handle "xsl" resources can also be done by calling 
 * {@link org.milyn.templating.TemplatingUtils#registerCDUCreators(org.milyn.Smooks)}.
 * 
 * <h4>2. Targeting "xsl" Templates</h4>
 * XSLTs can be specified in a file or as a "resdata" parameter (i.e. inline in the resource configuration).
 * <p/>
 * <i>File based spec</i>:
 * <pre>
 * &lt;smooks-resource  useragent="<i>useragent/profile</i>" selector="<i>target-element</i>" 
 *  path="<b>/com/acme/AcmeXslTemplate.xsl</b>" &gt;
 *  
 *  &lt;!-- (Optional) The action to be applied on the template content. Should the content 
 *          generated by the template:
 *          1. replace ("replace") the target element, or
 *          2. be added to ("addto") the target element, or
 *          3. be inserted before ("insertbefore") the target element, or
 *          4. be inserted after ("insertafter") the target element.
 *          Default "replace".--&gt;
 *  &lt;param name="<b>action</b>"&gt;<i>replace/addto/insertbefore/insertafter</i>&lt;/param&gt;
 * 
 *  &lt;!-- (Optional) Is this XSL template resource a complete XSL template, or just a <a href="#templatelets">"Template<u>let</u></a>".
 *          Default "true".--&gt;
 *  &lt;param name="<b>is-xslt-templatelet</b>"&gt;<i>true/false</i>&lt;/param&gt;
 * 
 *  &lt;!-- (Optional) Should the template be applied before (true) or 
 *          after (false) Smooks visits the child elements of the target element. 
 *          Default "false".--&gt;
 *  &lt;param name="<b>visitBefore</b>"&gt;<i>true/false</i>&lt;/param&gt;
 * 
 *  &lt;!-- (Optional) Template encoding. 
 *          Default "UTF-8".--&gt;
 *  &lt;param name="<b>encoding</b>"&gt;<i>encoding</i>&lt;/param&gt;
 *
 * &lt;/smooks-resource&gt;
 * </pre>
 * <p/>
 * <i>Parameter based spec (inline)</i>:
 * <pre>
 * &lt;smooks-resource  useragent="<i>useragent/profile</i>" selector="<i>target-element</i>"&gt;
 * 
 *  &lt;!-- (Mandatory) This parameter tells Smooks how to handle this resource i.e. to use
 *  		 {@link XslContentDeliveryUnitCreator}.  This is required because there's no "path" attribute
 *  		available on this configuration for Smooks to use to determine the resource type. 
 *  		See {@link org.milyn.cdr.SmooksResourceConfiguration#getResourceType()} --&gt;
 *  &lt;param name="<b>restype</b>"&gt;xsl&lt;/param&gt;
 * 
 *  &lt;!-- (Mandatory) This parameter tells Smooks how to handle this resource i.e. to use
 *  		 {@link XslContentDeliveryUnitCreator}. --&gt;
 *  &lt;param name="<b>resdata</b>"&gt;
 *  	&lt;![CDATA[
 *  		<i>XSL Template/<a href="#templatelets">Templatelet</a></i>
 *  	]]&gt;
 *  &lt;/param&gt;
 *  
 *  &lt;!-- (Optional) The action to be applied on the template content. Should the content 
 *          generated by the template:
 *          1. replace ("replace") the target element, or
 *          2. be added to ("addto") the target element, or
 *          3. be inserted before ("insertbefore") the target element, or
 *          4. be inserted after ("insertafter") the target element.
 *          Default "replace".--&gt;
 *  &lt;param name="<b>action</b>"&gt;<i>replace/addto/insertbefore/insertafter</i>&lt;/param&gt;
 * 
 *  &lt;!-- (Optional) Is this XSL template resource a complete XSL template, or just a <a href="#templatelets">"Templatelet"</a>.
 *          Default "true".--&gt;
 *  &lt;param name="<b>is-xslt-templatelet</b>"&gt;<i>true/false</i>&lt;/param&gt;
 * 
 *  &lt;!-- (Optional) Should the template be applied before (true) or 
 *          after (false) Smooks visits the child elements of the target element. 
 *          Default "false".--&gt;
 *  &lt;param name="<b>visitBefore</b>"&gt;<i>true/false</i>&lt;/param&gt;
 * 
 *  &lt;!-- (Optional) Template encoding. 
 *          Default "UTF-8".--&gt;
 *  &lt;param name="<b>encoding</b>"&gt;<i>encoding</i>&lt;/param&gt;
 * 
 * &lt;/smooks-resource&gt;
 * </pre>
 * 
 * <h3 id="templatelets">Templatelets</h3>
 * Templatelets are a convienient way of specifying templates.  When using "Templatelets", this creator 
 * class wraps the templatelet with the necessary XSL template code to make the template a complete XSL template
 * for the targeted DOM node.  It's simply a way of abreviating an xsl template resource.  Use of the Templatelet
 * feature can be disabled by specifying the "is-xslt-templatelet" parameter with a value of "false".
 * <p/>
 * <a href="doc-files/templatelet.xsl" type="text/plain">See the template used to wrap the templatelet</a>.
 * 
 * <h3>JavaBean Support</h3>
 * Support for injection of JavaBean values populated by the 
 * <a href="http://milyn.codehaus.org/downloads">Smooks JavaBean Cartridge</a> is supported through the 
 * <a href="http://xml.apache.org/xalan-j/">Xalan</a> extension {@link org.milyn.templating.xslt.XalanJavabeanExtension}.
 * 
 * @author tfennelly
 */
public class XslContentDeliveryUnitCreator implements ContentDeliveryUnitCreator {

	/**
	 * Logger.
	 */
	private static Log logger = LogFactory.getLog(XslContentDeliveryUnitCreator.class);
    /**
     * Synchonized template application system property key. 
     */
    public static final String ORG_MILYN_TEMPLATING_XSLT_SYNCHRONIZED = "org.milyn.templating.xslt.synchronized";

    /**
     * Public constructor.
     * @param config Configuration details for this ContentDeliveryUnitCreator.
     */
    public XslContentDeliveryUnitCreator(SmooksResourceConfiguration config) {        
    }
    
	/**
	 * Create an XSL based ContentDeliveryUnit instance ie from an XSL byte streamResult.
     * @param resourceConfig The SmooksResourceConfiguration for the XSL {@link ContentDeliveryUnit}
     * to be created.
     * @return XSL {@link ContentDeliveryUnit} instance.
	 * @see org.milyn.delivery.JavaContentDeliveryUnitCreator
     */
	public synchronized ContentDeliveryUnit create(SmooksResourceConfiguration resourceConfig) throws InstantiationException {
		try {
            XslProcessingUnit xslProcessingUnit = new XslProcessingUnit();
            xslProcessingUnit.setConfiguration(resourceConfig);
            return xslProcessingUnit;
		} catch (Exception e) {
			InstantiationException instanceException = new InstantiationException("XSL ProcessingUnit resource [" + resourceConfig.getResource() + "] not loadable.");
			instanceException.initCause(e);
			throw instanceException;
		}
	}

	/**
	 * XSLT template application ProcessingUnit.
	 * @author tfennelly
	 */
	private class XslProcessingUnit extends AbstractTemplateProcessingUnit {

		/**
		 * XSL template to be applied to the visited element.
		 */
		private Templates xslTemplate;
		/**
		 * Is this processor processing an XSLT <a href="#templatelets">Templatelet</a>.
		 */
		private boolean isTemplatelet;
        /**
         * Configuration flag indicating whether the result is to be streamed back into the
         * output tree, or readed to the DOM as Elements.  Streaming the result
         * is more performant - but you can't perform further manipulations on the DOM.
         * <p/>
         * Default is "true".
         */
        private boolean streamResult;
        /**
         * Is the template application synchronized or not.
         * <p/>
         * Xalan v2.7.0 has/had a threading issue - kick-on effect being that template application
         * must be synchronized.
         */
        private final boolean isSynchronized = Boolean.getBoolean(ORG_MILYN_TEMPLATING_XSLT_SYNCHRONIZED);

		protected void loadTemplate(SmooksResourceConfiguration resourceConfig) throws IOException, TransformerConfigurationException {
			byte[] xslBytes = resourceConfig.getBytes();
			TransformerFactory transformerFactory = TransformerFactory.newInstance();
			StreamSource xslStreamSource;
            String encoding = resourceConfig.getStringParameter("encoding", "UTF-8");

			// If it's not a full XSL template, we need to make it so by wrapping it.
            isTemplatelet = resourceConfig.getBoolParameter("is-xslt-templatelet", true);
            if(isTemplatelet) {
				String templateletWrapper = new String(StreamUtils.readStream(ClassUtil.getResourceAsStream("doc-files/templatelet.xsl", getClass())));
				String templatelet = new String(xslBytes);
				
				templateletWrapper = StringUtils.replace(templateletWrapper, "@@@templatelet@@@", templatelet);
				xslBytes = templateletWrapper.getBytes();
			}

            xslStreamSource = new StreamSource(new InputStreamReader(new ByteArrayInputStream(xslBytes), encoding));
            xslTemplate = transformerFactory.newTemplates(xslStreamSource);
            streamResult = resourceConfig.getBoolParameter("streamResult", true);
        }

		protected void visit(Element element, ExecutionContext executionContext) {
                Document ownerDoc = element.getOwnerDocument();
                Element transRes = ownerDoc.createElement("xsltrans");
                NodeList children = null;

                try {
                    if(isSynchronized) {
                        synchronized(xslTemplate) {
                            performTransform(element, transRes, ownerDoc);
                        }
                    } else {
                        performTransform(element, transRes, ownerDoc);
                    }
                } catch (Exception e) {
                    logger.error("Error applying XSLT to node [" + executionContext.getDocumentSource() + ":" + DomUtils.getXPath(element) + "]", e);
                    return;
                }

                if(isTemplatelet) {
                    // If the template in use on this resource is a templatelet, check for and remove the
                    // enclosing "root-do-not-remove" element i.e. the templatelet content is inside
                    // the "root-do-not-remove" element.
                    Element dontRemoveEl = DomUtils.getElement(transRes, "root-do-not-remove", 1, Namespace.SMOOKS_URI);
                    if(dontRemoveEl != null) {
                        children = dontRemoveEl.getChildNodes();
                    } else {
                        children = transRes.getChildNodes();
                    }
                } else {
                    children = transRes.getChildNodes();
                }

                // Process the templating action, supplying the templating result...
                processTemplateAction(element, children);
        }

        private void performTransform(Element element, Element transRes, Document ownerDoc) throws TransformerException {
            Transformer transformer;
            transformer = xslTemplate.newTransformer();

            if(false && !isTemplatelet && streamResult) {
                CharArrayWriter writer = new CharArrayWriter();
                transformer.transform(new DOMSource(element), new StreamResult(writer));
                transRes.appendChild(ownerDoc.createTextNode(writer.toString()));
            } else {
                transformer.transform(new DOMSource(element), new DOMResult(transRes));
            }
        }
    }
}
