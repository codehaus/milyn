/*
	Milyn - Copyright (C) 2006

	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License (version 2.1) as published by the Free Software 
	Foundation.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
    
	See the GNU Lesser General Public License for more details:    
	http://www.gnu.org/licenses/lgpl.txt
*/

package org.milyn.templating.xslt;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.milyn.cdr.SmooksResourceConfiguration;
import org.milyn.container.ExecutionContext;
import org.milyn.delivery.ContentDeliveryUnit;
import org.milyn.delivery.ContentDeliveryUnitCreator;
import org.milyn.io.StreamUtils;
import org.milyn.templating.AbstractTemplateProcessingUnit;
import org.milyn.util.ClassUtil;
import org.milyn.xml.DomUtils;
import org.milyn.xml.Namespace;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import java.io.ByteArrayInputStream;
import java.io.CharArrayWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URI;


/**
 * XSL {@link org.milyn.delivery.dom.DOMElementVisitor} Creator class.
 * <p/>
 * Creates {@link org.milyn.delivery.dom.DOMElementVisitor} instances for performing node/element level
 * <a href="http://www.w3.org/Style/XSL/">XSL</a> templating (aka XSLT).
 * <p/>
 * Template application can be done in a synchronized or unsynchronized fashion by setting
 * the system property "org.milyn.templating.xslt.synchronized".  According to the spec,
 * this should not be necessary.  However, Xalan 2.7.0 (for one) has a bug which results in
 * unsynchronized template application causing invalid transforms.
 * 
 * <h3>Resource Configuration</h3>
 * Two configurations are required in order to use <a href="http://www.w3.org/Style/XSL/">XSL</a>
 * based templating:
 * <ol>
 *  <li>A Configuration to register this {@link org.milyn.delivery.ContentDeliveryUnitCreator}
 *      implementation.  This configuration basically tells Smooks how to handle ".xsl" files.
 *  </li>
 *  <li>Configurations for targeting the "xsl" templates.
 *  </li>
 * </ol>
 * 
 * <h4>1. Registering XslContentDeliveryUnitCreator to Handle "xsl" resource types</h4>
 * <pre>
 * &lt;resource-config selector="cdu-creator"&gt;
 *     &lt;resource&gt;<b>org.milyn.templating.xslt.XslContentDeliveryUnitCreator</b>&lt;/resource&gt;
 *     &lt;param name="<b>restype</b>"&gt;xsl&lt;/param&gt;
 * &lt;/resource-config&gt;
 * </pre>
 * <p/>
 * Registration of the {@link XslContentDeliveryUnitCreator} to handle "xsl" resources can also be done by calling 
 * {@link org.milyn.templating.TemplatingUtils#registerCDUCreators(org.milyn.Smooks)}.
 * 
 * <h4>2. Targeting "xsl" Templates</h4>
 * The following is the basic configuration specification for XSL resources:
 * <pre>
 * &lt;resource-config selector="<i>target-element</i>"&gt;
 *     &lt;resource&gt;<b>XSL Resource - Inline or {@link org.milyn.resource.URIResourceLocator URI}</b>&lt;/resource&gt;
 *
 *     &lt;!-- (Optional) The action to be applied on the template content. Should the content
 *          generated by the template:
 *          1. replace ("replace") the target element, or
 *          2. be added to ("addto") the target element, or
 *          3. be inserted before ("insertbefore") the target element, or
 *          4. be inserted after ("insertafter") the target element.
 *          Default "replace".--&gt;
 *     &lt;param name="<b>action</b>"&gt;<i>replace/addto/insertbefore/insertafter</i>&lt;/param&gt;
 * 
 *     &lt;!-- (Optional) Is this XSL template resource a complete XSL template, or just a <a href="#templatelets">"Template<u>let</u></a>".
 *          Only relevant for inlined XSL resources.  URI based resource are always assumed to NOT be templatelets.
 *          Default "false" (for inline resources).--&gt;
 *     &lt;param name="<b>is-xslt-templatelet</b>"&gt;<i>true/false</i>&lt;/param&gt;
 * 
 *     &lt;!-- (Optional) Should the template be applied before (true) or
 *             after (false) Smooks visits the child elements of the target element.
 *             Default "false".--&gt;
 *     &lt;param name="<b>visitBefore</b>"&gt;<i>true/false</i>&lt;/param&gt;
 * 
 *     &lt;!-- (Optional) Template encoding.
 *          Default "UTF-8".--&gt;
 *     &lt;param name="<b>encoding</b>"&gt;<i>encoding</i>&lt;/param&gt;
 *
 * &lt;/resource-config&gt;
 * </pre>
 * <p/>
 * <i><u>Example - URI based XSLT spec</u></i>:
 * <pre>
 * &lt;resource-config selector="<i>target-element</i>"&gt;
 *     &lt;!-- 1. See {@link org.milyn.resource.URIResourceLocator} --&gt;
 *     &lt;resource&gt;/com/acme/order-transform.xsl&lt;/resource&gt;
 * &lt;/resource-config&gt;
 * </pre>
 * <p/>
 * <i><u>Example - Inlined XSLT spec</u></i>:
 * <pre>
 * &lt;resource-config selector="<i>target-element</i>"&gt;
 *     &lt;!-- 1. Note how we have to specify the resource type when it's inlined. --&gt;
 *     &lt;!-- 2. Note how the inlined XSLT is wrapped as an XML Comment. CDATA Section wrapping also works. --&gt;
 *     &lt;!-- 3. Note if the inlined XSLT is a <a href="#templatelets">templatelet</a>, is-xslt-templatelet=true must be specified. --&gt;
 *     &lt;resource <b color="red">type="xsl"</b>&gt;
 *         &lt;!--
 *            <i>Inline XSLT....</i>
 *         --&gt;
 *     &lt;/resource&gt;
 *     <b color="red">&lt;param name="is-xslt-templatelet"&gt;true&lt;/param&gt;</b>
 * &lt;/resource-config&gt;
 * </pre>
 *
 * <h3 id="templatelets">Templatelets</h3>
 * Templatelets are a convenient way of specifying an XSL Stylesheet.  When using "Templatelets", you simply specify the
 * body of an XSL template. This creator then wraps that body to make a complete XSL Stylesheet with a single template matched to the
 * element targeted by the Smooks resource configuration in question.  This feature only applies
 * to inlined XSL resources and in this case, it's <u>OFF</u> by default.  To use this feature,
 * you must specify the "is-xslt-templatelet" parameter with a value of "true".
 * <p/>
 * This feature will not work in all situations since you'll often need to specify a full stylesheet in order to
 * specify namespaces etc.  It's just here for convenience.
 * <p/>
 * <a href="doc-files/templatelet.xsl" type="text/plain">See the template used to wrap the templatelet</a>.
 * 
 * <h3>JavaBean Support</h3>
 * Support for injection of JavaBean values populated by the 
 * <a href="http://milyn.codehaus.org/downloads">Smooks JavaBean Cartridge</a> is supported through the 
 * <a href="http://xml.apache.org/xalan-j/">Xalan</a> extension {@link org.milyn.templating.xslt.XalanJavabeanExtension}.
 * 
 * @author tfennelly
 */
public class XslContentDeliveryUnitCreator implements ContentDeliveryUnitCreator {

    /**
     * Parameter name for templating feature.
     */
    public static final String IS_XSLT_TEMPLATELET = "is-xslt-templatelet";
	/**
	 * Logger.
	 */
	private static Log logger = LogFactory.getLog(XslContentDeliveryUnitCreator.class);
    /**
     * Synchonized template application system property key. 
     */
    public static final String ORG_MILYN_TEMPLATING_XSLT_SYNCHRONIZED = "org.milyn.templating.xslt.synchronized";

    /**
     * Public constructor.
     * @param config Configuration details for this ContentDeliveryUnitCreator.
     */
    public XslContentDeliveryUnitCreator(SmooksResourceConfiguration config) {        
    }
    
	/**
	 * Create an XSL based ContentDeliveryUnit instance ie from an XSL byte streamResult.
     * @param resourceConfig The SmooksResourceConfiguration for the XSL {@link ContentDeliveryUnit}
     * to be created.
     * @return XSL {@link ContentDeliveryUnit} instance.
	 * @see org.milyn.delivery.JavaContentDeliveryUnitCreator
     */
	public synchronized ContentDeliveryUnit create(SmooksResourceConfiguration resourceConfig) throws InstantiationException {
		try {
            XslProcessingUnit xslProcessingUnit = new XslProcessingUnit();
            xslProcessingUnit.setConfiguration(resourceConfig);
            return xslProcessingUnit;
		} catch (Exception e) {
			InstantiationException instanceException = new InstantiationException("XSL ProcessingUnit resource [" + resourceConfig.getResource() + "] not loadable.");
			instanceException.initCause(e);
			throw instanceException;
		}
	}

	/**
	 * XSLT template application ProcessingUnit.
	 * @author tfennelly
	 */
	private class XslProcessingUnit extends AbstractTemplateProcessingUnit {

		/**
		 * XSL template to be applied to the visited element.
		 */
		private Templates xslTemplate;
		/**
		 * Is this processor processing an XSLT <a href="#templatelets">Templatelet</a>.
		 */
		private boolean isTemplatelet;
        /**
         * Configuration flag indicating whether the result is to be streamed back into the
         * output tree, or readed to the DOM as Elements.  Streaming the result
         * is more performant - but you can't perform further manipulations on the DOM.
         * <p/>
         * Default is "true".
         */
        private boolean streamResult;
        /**
         * Is the template application synchronized or not.
         * <p/>
         * Xalan v2.7.0 has/had a threading issue - kick-on effect being that template application
         * must be synchronized.
         */
        private final boolean isSynchronized = Boolean.getBoolean(ORG_MILYN_TEMPLATING_XSLT_SYNCHRONIZED);

        protected void loadTemplate(SmooksResourceConfiguration resourceConfig) throws IOException, TransformerConfigurationException {
			byte[] xslBytes = resourceConfig.getBytes();
			TransformerFactory transformerFactory = TransformerFactory.newInstance();
			StreamSource xslStreamSource;
            String encoding = resourceConfig.getStringParameter("encoding", "UTF-8");
            boolean isInlineXSL;

            try {
                // If the resource resolves as a valid URI, then it's not an inline resource.
                new URI(resourceConfig.getResource());
                isInlineXSL = false;
            } catch(Exception e) {
                isInlineXSL = true;
            }

            // If it's not a full XSL template, we need to make it so by wrapping it.
            isTemplatelet = isTemplatelet(isInlineXSL, resourceConfig, new String(xslBytes));
            if(isTemplatelet) {
				String templateletWrapper = new String(StreamUtils.readStream(ClassUtil.getResourceAsStream("doc-files/templatelet.xsl", getClass())));
				String templatelet = new String(xslBytes);
				
				templateletWrapper = StringUtils.replace(templateletWrapper, "@@@templatelet@@@", templatelet);
				xslBytes = templateletWrapper.getBytes();
			}

            xslStreamSource = new StreamSource(new InputStreamReader(new ByteArrayInputStream(xslBytes), encoding));
            xslTemplate = transformerFactory.newTemplates(xslStreamSource);
            streamResult = resourceConfig.getBoolParameter("streamResult", true);
        }

        private boolean isTemplatelet(boolean inlineXSL, SmooksResourceConfiguration resourceConfig, String templateCode) {
            boolean isTemplatelet = (inlineXSL && resourceConfig.getBoolParameter(IS_XSLT_TEMPLATELET, false));

            // If it's configured as a templatelet, but the code looks like it's a
            // full template, log a warning...
            if(isTemplatelet && templateCode.indexOf(":stylesheet>") != -1) {
                logger.warn("The following XSL resource is configured as a templatelet, but looks as though it may be a complete stylesheet i.e. not a templatelet. You may want to remove the 'is-xslt-templatelet' parameter. Resource:\n" + resourceConfig);
            }
            // If it's not configured as a templatelet, but the code looks like it's a not
            // full template, log a warning...
            if(!isTemplatelet && templateCode.indexOf(":stylesheet>") == -1) {
                logger.warn("The following XSL resource is NOT configured as a templatelet, but looks as though it may be an incomplete stylesheet i.e. it may be templatelet.  If so, it must be explicitly configured as a templatelet. Resource:\n" + resourceConfig);
            }

            return isTemplatelet;
        }

        protected void visit(Element element, ExecutionContext executionContext) {
                Document ownerDoc = element.getOwnerDocument();
                Element transRes = ownerDoc.createElement("xsltrans");
                NodeList children = null;

                try {
                    if(isSynchronized) {
                        synchronized(xslTemplate) {
                            performTransform(element, transRes, ownerDoc);
                        }
                    } else {
                        performTransform(element, transRes, ownerDoc);
                    }
                } catch (Exception e) {
                    logger.error("Error applying XSLT to node [" + executionContext.getDocumentSource() + ":" + DomUtils.getXPath(element) + "]", e);
                    return;
                }

                if(isTemplatelet) {
                    // If the template in use on this resource is a templatelet, check for and remove the
                    // enclosing "root-do-not-remove" element i.e. the templatelet content is inside
                    // the "root-do-not-remove" element.
                    Element dontRemoveEl = DomUtils.getElement(transRes, "root-do-not-remove", 1, Namespace.SMOOKS_URI);
                    if(dontRemoveEl != null) {
                        children = dontRemoveEl.getChildNodes();
                    } else {
                        children = transRes.getChildNodes();
                    }
                } else {
                    children = transRes.getChildNodes();
                }

                // Process the templating action, supplying the templating result...
                processTemplateAction(element, children);
        }

        private void performTransform(Element element, Element transRes, Document ownerDoc) throws TransformerException {
            Node transformNode = element;
            Transformer transformer;
            transformer = xslTemplate.newTransformer();

            if(element == element.getOwnerDocument().getDocumentElement()) {
                transformNode = element.getOwnerDocument();
            }

            if(false && !isTemplatelet && streamResult) {
                CharArrayWriter writer = new CharArrayWriter();
                transformer.transform(new DOMSource(transformNode), new StreamResult(writer));
                transRes.appendChild(ownerDoc.createTextNode(writer.toString()));
            } else {
                transformer.transform(new DOMSource(transformNode), new DOMResult(transRes));
            }
        }
    }
}
